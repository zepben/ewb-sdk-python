#  Copyright 2025 Zeppelin Bend Pty Ltd
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at https://mozilla.org/MPL/2.0/.
from typing import TypedDict, Tuple, Any, Callable, Union, Literal
from lark import Lark, Tree, Token

from zepben.evolve import Tracing, downstream, upstream, NetworkConsumerClient, NetworkTrace, Equipment, IdentifiedObject


ComparisonType = Literal['<', '<=', '=', '>', '>=', 'like']

class VarsType(TypedDict):
    trace: NetworkTrace
    FEEDER: Tuple[str, Any]  # TODO: replace any with the actual type


class MaxQLRunner:

    def __init__(self, ewb_server_client: NetworkConsumerClient):
        self.ewb_client = ewb_server_client
        with open('grammar.lark') as file:
            self.parser = Lark(file)

    async def run(self, query_string: str):
        """
        Executes the `query_string` passed in.

        eg::

            with Feeder_mRID select where is Breaker
            with Feeder_mRID select where name like Partial_mRID
            with Feeder_mRID select where length < 10
            with Feeder_mRID trace downstream from Equipment_mRID
            with Feeder_mRID trace upstream from Equipment_mRID
            with Feeder_mRID trace from Equipment_mRID stopping at is PowerTransformer
            with Feeder_mRID trace upstream from Equipment_mRID stopping at is PowerTransformer


        :param query_string:
        :return:
        """
        return await self._process(self._parse(query_string))

    async def _process(self, child: Union[Tree, Token], trace: NetworkTrace = None):
        """
        This is a recursive function to consume and process AST's generated by the parser.

        TODO: actually explain the crazy re-entrant logic here..

        :param child: AST Tree
        :param trace: NetworkTrace, dont pass one in unless you know what you're doing
        :return: results of the executed AST passed in
        """
        if isinstance(child, Token):
            child_type = child.type

            if child_type == 'FEEDER':
                # Load the network under `FEEDER`
                del (await self.ewb_client.get_equipment_container(child.value)).result
            elif child_type == 'DIRECTION':
                trace.add_condition(self._parse_direction_condition(child))
            elif child_type == 'TRACE_START':
                io = (await self.ewb_client.get_identified_object(child.value)).result
                trace.add_start_item(io)
            else:
                raise self._parsing_error(child.data)

        elif isinstance(child, Tree):
            tree_data = child.data

            if tree_data == 'start':
                result = None
                for _child in child.children:
                    result = await self._process(_child)
                return result

            elif tree_data == 'trace':
                trace = Tracing.network_trace()

                for trace_child in child.children:
                    if isinstance(trace_child, Tree):  # Following the pattern here, this should call _process... it doesn't, there's reasons
                        # as NetworkTrace supports multiple stop conditions, this will already support multiple OR conditions
                        # to implement AND, we will need to build a function that builds functions, lol...
                        condition_func = self._parse_condition_type(trace_child)
                        trace.add_stop_condition(lambda step, context: condition_func(step.path.to_equipment))

                    elif isinstance(trace_child, Token):
                        await self._process(trace_child, trace)
                return trace

            elif tree_data == 'select':
                # TODO if we allow multiple chained conditions, this will need to build an AND|OR function.
                assert len(child.children) == 1  # this assertion will never fail until we do the above
                condition_func = self._parse_condition_type(child.children[0])
                return [it for it in self.ewb_client.service.objects() if condition_func(it)]

            else:
                raise self._parsing_error(child.data)

    _direction_condition_token_map = dict(
        downstream=downstream(),
        upstream=upstream()
    )

    def _parse_direction_condition(self, token: Token):
        """Return the direction condition matching the token passed in"""
        if condition := self._direction_condition_token_map.get(token.value):
            return condition
        raise self._parsing_error(token.value)

    def _parse_condition_type(self, tree: Tree) -> Callable[[IdentifiedObject], bool]:
        """This function exists purely to handle isinstance conditions"""
        if tree.data == 'condition':
            if tree.children[0].type == "IS":
                return lambda obj: self.has_class(obj, tree.children[1])
            attr, _operator, value = [c.value for c in tree.children]
            return lambda obj: self._check_attr(obj, attr, self._get_comparator_function(_operator, value))

        else:
            raise self._parsing_error(tree.data)

    @staticmethod
    def _get_comparator_function(comparison: ComparisonType, value: Union[str, int]) -> Callable[[str], bool]:
        """Returns a lambda function appropriate for the `comparison` operator passed in"""
        if comparison == "<":
            return lambda attr: float(attr) < float(value)
        elif comparison == "<=":
            return lambda attr: float(attr) <= float(value)
        elif comparison == "=" or comparison == "==":
            return lambda attr: attr == value
        elif comparison == ">=":
            return lambda attr: float(attr) >= float(value)
        elif comparison == ">":
            return lambda attr: float(attr) > float(value)
        elif comparison.lower() == "like":
            return lambda attr: value in attr
        else:
            raise ValueError(f"unknown select condition operator '{comparison}'")

    @staticmethod
    def _check_attr(io: Equipment, attr: str, compare: Callable[[Any], bool]) -> bool:
        """:return: `True` if `to_equipment.attr` passes the `compare` function. `False otherwise"""
        try:
            return compare(getattr(io, attr))
        except AttributeError:
            return False

    @staticmethod
    def has_class(obj: Any, class_name: str):
        """Case-insensitive string match on any Class in an IdentifiedObjects `__mro__`"""
        return any(cls.__name__.lower() == class_name.lower() for cls in obj.__class__.__mro__)

    def _parse(self, raw: str) -> Tree:
        return self.parser.parse(raw)

    @staticmethod
    def _parsing_error(msg: str):
        """NOTE: This is ONLY to be called in cases where the code path is only reachable due to a grammar problem."""
        return Exception('INTERNAL ERROR: If your adding a keyword, you forgot to add the logic to the runner. '
                        f'Otherwise this {msg} should have been caught by the parser')

